{"ast":null,"code":"/*\r\n\r\n                                   O |   | X\r\n                                   ---------\r\n                                   X |   | X\r\n                                   ---------\r\n                                     | O | O\r\n\r\n                             //       ||        \\\\\r\n\r\n                O | X | X          O |   | X        O |   | X\r\n                ---------          ---------        ---------\r\n                X |   | X          X | X | X        X |   | X\r\n                ---------          ---------        ---------\r\n                  | O | O            | O | O        X | O | O\r\n\r\n              //          \\\\                     //          \\\\\r\n\r\n        O | X | X          O | X | X        O | O | X       O |   | X\r\n        ---------          ---------        ---------       ---------\r\n        X | O | X          X |   | X        X |   | X       X | O | X\r\n        ---------          ---------        ---------       ---------\r\n          | O | O          O | O | O        X | O | O       X | O | O\r\n\r\n                                        //\r\n\r\n                                   O | O | X\r\n                                   ---------\r\n                                   X | X | X\r\n                                   ---------\r\n                                   O | O | O\r\n\r\n*/\n// this is the board flattened and filled with some values to easier asses the Artificial Inteligence.\nvar origBoard = [\"O\", 1, \"X\", \"X\", 4, \"X\", 6, \"O\", \"O\"]; // human\n\nvar huPlayer = \"O\"; // ai\n\nvar aiPlayer = \"X\"; // keep track of function calls\n\nvar fc = 0; // finding the ultimate play on the game that favors the computer\n\nvar bestSpot = minimax(origBoard, aiPlayer); //loging the results\n\nconsole.log(\"index: \" + bestSpot.index);\nconsole.log(\"function calls: \" + fc); // the main minimax function\n\nfunction minimax(newBoard, player) {\n  //keep track of function calls;\n  fc++; //available spots\n\n  var availSpots = emptyIndexies(newBoard); // checks for the terminal states such as win, lose, and tie and returning a value accordingly\n\n  if (winning(newBoard, huPlayer)) {\n    return {\n      score: -10\n    };\n  } else if (winning(newBoard, aiPlayer)) {\n    return {\n      score: 10\n    };\n  } else if (availSpots.length === 0) {\n    return {\n      score: 0\n    };\n  } // an array to collect all the objects\n\n\n  var moves = []; // loop through available spots\n\n  for (var i = 0; i < availSpots.length; i++) {\n    //create an object for each and store the index of that spot that was stored as a number in the object's index key\n    var move = {};\n    move.index = newBoard[availSpots[i]]; // set the empty spot to the current player\n\n    newBoard[availSpots[i]] = player; //if collect the score resulted from calling minimax on the opponent of the current player\n\n    if (player == aiPlayer) {\n      var result = minimax(newBoard, huPlayer);\n      move.score = result.score;\n    } else {\n      var result = minimax(newBoard, aiPlayer);\n      move.score = result.score;\n    } //reset the spot to empty\n\n\n    newBoard[availSpots[i]] = move.index; // push the object to the array\n\n    moves.push(move);\n  } // if it is the computer's turn loop over the moves and choose the move with the highest score\n\n\n  var bestMove;\n\n  if (player === aiPlayer) {\n    var bestScore = -10000;\n\n    for (var i = 0; i < moves.length; i++) {\n      if (moves[i].score > bestScore) {\n        bestScore = moves[i].score;\n        bestMove = i;\n      }\n    }\n  } else {\n    // else loop over the moves and choose the move with the lowest score\n    var bestScore = 10000;\n\n    for (var i = 0; i < moves.length; i++) {\n      if (moves[i].score < bestScore) {\n        bestScore = moves[i].score;\n        bestMove = i;\n      }\n    }\n  } // return the chosen move (object) from the array to the higher depth\n\n\n  return moves[bestMove];\n} // returns the available spots on the board\n\n\nfunction emptyIndexies(board) {\n  return board.filter(function (s) {\n    return s != \"O\" && s != \"X\";\n  });\n} // winning combinations using the board indexies for instace the first win could be 3 xes in a row\n\n\nfunction winning(board, player) {\n  if (board[0] == player && board[1] == player && board[2] == player || board[3] == player && board[4] == player && board[5] == player || board[6] == player && board[7] == player && board[8] == player || board[0] == player && board[3] == player && board[6] == player || board[1] == player && board[4] == player && board[7] == player || board[2] == player && board[5] == player && board[8] == player || board[0] == player && board[4] == player && board[8] == player || board[2] == player && board[4] == player && board[6] == player) {\n    return true;\n  } else {\n    return false;\n  }\n}","map":{"version":3,"sources":["C:\\Users\\Edson\\Desktop\\reacjs\\Tictactoe2018\\src\\utils\\helpers.js"],"names":["origBoard","huPlayer","aiPlayer","fc","bestSpot","minimax","console","log","index","newBoard","player","availSpots","emptyIndexies","winning","score","length","moves","i","move","result","push","bestMove","bestScore","board","filter","s"],"mappings":"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","sourcesContent":["/*\r\n\r\n                                   O |   | X\r\n                                   ---------\r\n                                   X |   | X\r\n                                   ---------\r\n                                     | O | O\r\n\r\n                             //       ||        \\\\\r\n\r\n                O | X | X          O |   | X        O |   | X\r\n                ---------          ---------        ---------\r\n                X |   | X          X | X | X        X |   | X\r\n                ---------          ---------        ---------\r\n                  | O | O            | O | O        X | O | O\r\n\r\n              //          \\\\                     //          \\\\\r\n\r\n        O | X | X          O | X | X        O | O | X       O |   | X\r\n        ---------          ---------        ---------       ---------\r\n        X | O | X          X |   | X        X |   | X       X | O | X\r\n        ---------          ---------        ---------       ---------\r\n          | O | O          O | O | O        X | O | O       X | O | O\r\n\r\n                                        //\r\n\r\n                                   O | O | X\r\n                                   ---------\r\n                                   X | X | X\r\n                                   ---------\r\n                                   O | O | O\r\n\r\n*/\r\n// this is the board flattened and filled with some values to easier asses the Artificial Inteligence.\r\nvar origBoard = [\"O\",1 ,\"X\",\"X\",4 ,\"X\", 6 ,\"O\",\"O\"];\r\n\r\n// human\r\nvar huPlayer = \"O\";\r\n// ai\r\nvar aiPlayer = \"X\";\r\n\r\n\r\n// keep track of function calls\r\nvar fc = 0;\r\n\r\n// finding the ultimate play on the game that favors the computer\r\nvar bestSpot = minimax(origBoard, aiPlayer);\r\n\r\n//loging the results\r\nconsole.log(\"index: \" + bestSpot.index);\r\nconsole.log(\"function calls: \" + fc);\r\n\r\n// the main minimax function\r\nfunction minimax(newBoard, player){\r\n  \r\n  //keep track of function calls;\r\n  fc++;\r\n\r\n  //available spots\r\n  var availSpots = emptyIndexies(newBoard);\r\n\r\n  // checks for the terminal states such as win, lose, and tie and returning a value accordingly\r\n  if (winning(newBoard, huPlayer)){\r\n     return {score:-10};\r\n  }\r\n  else if (winning(newBoard, aiPlayer)){\r\n    return {score:10};\r\n  }\r\n  else if (availSpots.length === 0){\r\n    return {score:0};\r\n  }\r\n\r\n// an array to collect all the objects\r\n  var moves = [];\r\n\r\n  // loop through available spots\r\n  for (var i = 0; i < availSpots.length; i++){\r\n    //create an object for each and store the index of that spot that was stored as a number in the object's index key\r\n    var move = {};\r\n    move.index = newBoard[availSpots[i]];\r\n\r\n    // set the empty spot to the current player\r\n    newBoard[availSpots[i]] = player;\r\n\r\n    //if collect the score resulted from calling minimax on the opponent of the current player\r\n    if (player == aiPlayer){\r\n      var result = minimax(newBoard, huPlayer);\r\n      move.score = result.score;\r\n    }\r\n    else{\r\n      var result = minimax(newBoard, aiPlayer);\r\n      move.score = result.score;\r\n    }\r\n\r\n    //reset the spot to empty\r\n    newBoard[availSpots[i]] = move.index;\r\n\r\n    // push the object to the array\r\n    moves.push(move);\r\n  }\r\n\r\n// if it is the computer's turn loop over the moves and choose the move with the highest score\r\n  var bestMove;\r\n  if(player === aiPlayer){\r\n    var bestScore = -10000;\r\n    for(var i = 0; i < moves.length; i++){\r\n      if(moves[i].score > bestScore){\r\n        bestScore = moves[i].score;\r\n        bestMove = i;\r\n      }\r\n    }\r\n  }else{\r\n\r\n// else loop over the moves and choose the move with the lowest score\r\n    var bestScore = 10000;\r\n    for(var i = 0; i < moves.length; i++){\r\n      if(moves[i].score < bestScore){\r\n        bestScore = moves[i].score;\r\n        bestMove = i;\r\n      }\r\n    }\r\n  }\r\n\r\n// return the chosen move (object) from the array to the higher depth\r\n  return moves[bestMove];\r\n}\r\n\r\n// returns the available spots on the board\r\nfunction emptyIndexies(board){\r\n  return  board.filter(s => s != \"O\" && s != \"X\");\r\n}\r\n\r\n// winning combinations using the board indexies for instace the first win could be 3 xes in a row\r\nfunction winning(board, player){\r\n if (\r\n        (board[0] == player && board[1] == player && board[2] == player) ||\r\n        (board[3] == player && board[4] == player && board[5] == player) ||\r\n        (board[6] == player && board[7] == player && board[8] == player) ||\r\n        (board[0] == player && board[3] == player && board[6] == player) ||\r\n        (board[1] == player && board[4] == player && board[7] == player) ||\r\n        (board[2] == player && board[5] == player && board[8] == player) ||\r\n        (board[0] == player && board[4] == player && board[8] == player) ||\r\n        (board[2] == player && board[4] == player && board[6] == player)\r\n        ) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}